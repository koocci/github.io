---
layout: post
title:  "[DataBase] DB & Secure"
date:   2018-05-12 17:18:00 +0900
categories: DataBase
tags: [DB, 보안, 면접]

---

## DB & Sequrity 면접 질문 1
---


![DB](http://farm3.static.flickr.com/2276/2529599699_c84d0aaf14_z.jpg)

아무래도 DB관련 자격증이 있다보니 DB에 대한 내용을 물어볼 때가 있다. 또한, 보안에는 크게 자신없는데 보안에 관련해 질문을 받을 때가 많다.

따라서 내가 사용했던 내용, 내가 받았던 면접 내용을 토대로 이를 정리해보려고 한다.

---

### DataBase의 샤딩과 파티셔닝이 무엇인가?, 파티셔닝은 무엇을 나누는 것인가?

---

먼저 **파티셔닝(Partitioning)** 에 대해 알아보자.

**파티셔닝(Partitioning)** 이란,  데이터베이스를 여러 부분으로 분할하는 것이다.

즉, 큰 테이블이나 인덱스를 관리하기 쉬운 조각으로, 물리적으로 분할하는 것을 의미한다.

파티셔닝은 중요한 튜닝기법중 하나로, 데이터가 너무 커져서, 조회하는 시간이 길어질 때 또는 관리 용이성, 성능, 가용성 등의 향상을 이유로 행해지는 것이 일반적이다.

가장 일반적인 것은 분산 데이터베이스 분할이다.

각 파티션이 여러 노드에 분산 배치되어 사용자가 각 노드에서 로컬 트랜잭션을 수행할 수 있다.

이것은 가용성과 보안을 유지하면서 특정 뷰에 관한 일반 트랜잭션의 성능을 향상시킨다.

데이터베이스의 분할, 각각 (테이블, 인덱스, 트랜잭션 로그를 각각 유지했다) 작은 데이터베이스가 되도록 분할 방법과 하나의 테이블만 같이 선택된 요소만 분리하는 방법이 있다.

파티셔닝에는 크게 2가지로 나누어지는데 **수평 분할(horizontal partitioning)** 과 **수직 분할(vertical partitioning)** 이다.

1. 수평 분할

하나의 테이블의 각 행을 다른 테이블에 분산하는 것이다.

예를 들어, 고객 데이터 테이블을 성별에 따라 ‘남녀’로 나누어 CustomerMen과 CustomerWomen 두 개의 테이블로 분할한다. 테이블은 2개로 분할되지만, 모든 고객을 나타내기 위해 양자를 결합한 뷰를 생성한다.

2. 수직 분할

테이블의 일부 열을 빼내는 형태로 분할한다.

흔히, **정규화** 는 수직 분할의 과정이다.

수직 분할에는 여러 저장 장치를 사용할 수도 있고, 예를 들어 별로 사용되지 않는 열이나 매우 자릿수가 많은 열을 다른 장치에 두는 등의 조치를 생각할 수 있다.

명시적으로 하거나, 암묵적으로 하는 경우도 있지만, 이런 종류의 분할을 **열 분할(row splitting)** 이라고도 부른다.

자주 묻는 수직 분할 열 내용의 사용 빈도에 따라 분할하는 것이다.

분할된 테이블들을 포함하는 뷰를 생성하면 원래의 경우보다 성능이 저하되지만, 사용 빈도가 높은 데이터에만 액세스할 경우 성능이 향상된다.

예를 들어, 뉴스를 서비스할 때, 고객들은 최근의 데이터를 가장 많이 조회할 것이다. 이 경우 1개월 전의 데이터를 다른 테이블에 두면, 훨씬 효율적으로 검색할 수 있을 것이다.

분할의 기준은 다음과 같다.

1. 범위 분할 (range partitioning)

분할 키 값이 범위 내에 있는지 여부로 구분한다. 예를 들어, 우편 번호를 분할 키로 수평 분할하는 경우이다.

2. 목록 분할 (list partitioning)

값 목록에 파티션을 할당 분할 키 값을 그 목록에 비추어 파티션을 선택한다. 예를 들어, Country 라는 컬럼의 값이 Iceland , Norway , Sweden , Finland , Denmark 중 하나에 있는 행을 빼낼 때 북유럽 국가 파티션을 구축 할 수 있다.

3. 해시 분할 (hash partitioning)

해시 함수의 값에 따라 파티션에 포함할지 여부를 결정한다. 예를 들어, 4개의 파티션으로 분할하는 경우 해시 함수는 0-3의 정수를 돌려준다.

4. 합성 분할 (composite partitioning)

상기 기술을 결합하는 것을 의미하며, 예를 들면 먼저 범위 분할하고, 다음에 해시 분할 같은 것을 생각할 수 있다. 컨시스턴트 해시법은 해시 분할 및 목록 분할의 합성으로 간주 될 수 있고 키 공간을 해시 축소함으로써 일람할 수 있게 한다.


[출처 : https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EB%B6%84%ED%95%A0](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EB%B6%84%ED%95%A0)


그렇다면, **샤딩(Sharding)** 은 무엇인가?

**샤딩** 은 데이타베이스의 용량 한계를 극복하기 위한 기술이면서, 물리적으로 다른 데이터베이스에 데이터를 수평 분할 방식으로 분산 저장하고 조회하는 방법이다.

예를 들어, '주민' 테이블이 여러 DB에 있을 때, 서현동 주민에 대한 정보는 A DB에, 정자동 주민에 대한 정보는 B DB에 저장되도록 하는 방식을 말한다. 여러 데이터베이스를 대상으로 작업해야 하기 때문에 경우에 따라서는 기능에 제약이 있을 수 있고(JOIN 연산 등) 일관성(consistency)과 복제(replication) 등에서 불리한 점이 많다.

[출처 : https://d2.naver.com/helloworld/14822](https://d2.naver.com/helloworld/14822)
[출처 : http://bcho.tistory.com/670](http://bcho.tistory.com/670)

---

### 간단한 SQL 질문.

---

주어진 상황에 따라 SQL 문을 만들어보라는 질문을 받은 적도 있다.

물론, Group 이나, Order, Join에 대한 내용을 명확히 알고 있을 필요가 있다.

또한, SQL 작성 시, 올바른 순서도 중요하다.

SQL문 코딩규칙은 아래와 같다.

    SQL구문은 모두 대문자로 사용하도록 한다.
    콤마 후에는 한 칸을 띄운다.
    계속되는 콤마는 줄 앞에 위치시킨다.
    Table의 alias명을 T1,T2,T3,T4 순으로 부여한다.
    괄호 사용시는 괄호시작점 과 끝점에 공백을 주지 않는다.
    <,> 사용시는 항상 = 과 함께 사용한다.
    연산자 기준으로 양쪽에 공백을 준다.
    FROM 절은 select-list 절 다음 줄 앞에 위치시킨다.
    WHERE절은 FROM절 다음 줄 앞에 위치시킨다.
    GROUP BY 절은 WHERE절 다음 줄 앞에 위치시킨다.
    ORDER BY 절은 맨 마지막 줄 앞에 위치시킨다.
    Where 절의 and는 줄 앞에 위치시키며, 항상 두 칸 공백을 준다.
    Subqeury 또는 Inline view는 항상 괄호로 묶는다.
    SQL문 안에는 comment를 사용하지 않는다.
    SELECT * 를 사용하지 않으며, 필요한 컬럼을 명시한다.
    INSERT ~ VALUES 절내에 컬럼을 지정한다.

기본 Syntax이다.

    SELECT column_name1, column_name2
      , column_name3
    FROM table_name T1, table_name T2
    WHERE expr operator
      AND expr operator
    GROUP BY column_name
      HAVING ...
    ORDER BY column_name

    INSERT INTO table_name (COL1,COL2) VALUES(:V_COL1,:V_COL2)

    UPDATE table_name
          SET column_name, ….
    WHERE expr operator


[출처: http://landboys.tistory.com/entry/SQL-SQL-작성-가이드](http://landboys.tistory.com/entry/SQL-SQL-%EC%9E%91%EC%84%B1-%EA%B0%80%EC%9D%B4%EB%93%9C)

DB에 대한 내용 정리는 다음 기회에 하도록 하고, 이번엔 면접관련해서만 알아보았다.

---

## 보안

---

보안은 사실 내가 좀 취약한 부분이다.

따로 공부해 본적이 없다보니, 기본적인 내용에서 막힐 때도 있다.

일단 면접 질문만 우선 정리하겠다.

---

### 암호화 공개키 대칭키에 대해 설명해보라

---

**대칭키** 의 경우, 송신 측과 수신 측이 동일한 **비밀 키** 를 사용한다.

해당 키는 사전에 양 측이 가지고 있어야 하며, 암복호화 속도가 빠르지만 키를 관리하기가 까다롭다. (여러명과 암호화를 진행했다면, 개개별로 모든 암호 키를 관리해야한다.)

A를 암호화 하고 싶을 때, **비밀 키** 를 이용해 암호화 하고, 암호화 된 A를 보는 것도 같은 **비밀 키** 를 사용하는 것이다.

**공개키** 의 경우, 암복호화에 서로 **다른 2개의 키** 를 사용한다.

한가지는 **공개키(Public Key)** 이고, 다른 한가지는 **비밀키(Private Key)** 이다.

공개키로 암호화한 자료는 그 쌍의 비밀키로만 복호화가 가능하고, 비밀키로 암호화한 자료는 공개키로만 복호화가 가능하다.

그 용도는 다음과 같다.

1. 송신(공개키) -> 수신(개인키) : 개인키를 지닌 수신자만 데이터에 접근할 수 있으므로, 보안이 중요한 경우 사용된다.
2. 송신(개인키) -> 수신(공개키) : 송신자가 보낸 데이터의 신뢰성 보장이 필요한 경우 사용된다.

A를 암호화하고 싶으면, 비밀 키로 함호화를 하고, 해당 키를 인증기관을 통해, 공개 키를 얻게 된다. 해당 공개 키를 가진 사람은 암호화 된 A를 보고 싶을 때, 공개 키로 복호화를 하며, 그럼 A가 보냈다는 것이 확실히 인증된다.

[출처 : http://brownbears.tistory.com/332](http://brownbears.tistory.com/332)

[출처 : https://dwncs.wordpress.com/2017/06/23/https/](https://dwncs.wordpress.com/2017/06/23/https/)

---

#### HTTPs

---

아무래도 암호화에 대해 말하면 HTTPS 에 대한 내용이 나오기 마련이다.

따라서, 어떻게 HTTPS 가 진행 되는지 알아보자.

HTTPS 프로토콜은 SSL 포로토콜 위에서 동작한다.

그럼, SSL 인증서를 알아보자.

SSL 인증서는 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서이다.

클라이언트가 서버에 접속하면 서버는 클라이언트에게 해당 인증서 정보를 전달한다.

클라이언트는 인증서 정보의 신뢰도를 검증하고, 다음으로 넘어간다.

해당 검증의 이점은 다음과 같다.

1. 통신 내용이 공격자에게 노출되는 것을 막을 수 있다.
2. 클라이언트가 접속하려는 서버가 신뢰 할 수 있는 서버인지를 판단할 수 있다.
3. 통신 내용의 악의적인 변경을 방지할 수 있다.

SSL 인증서의 역할은 크게 2가지이다.

1. 클라이언트가 접속한 서버가 신뢰 할 수 있는 서버임을 보장한다.
2. SSL 통신에 사용할 공개키를 클라이언트에게 제공한다.

위에 1번사항을 해주는 것이 CA이다.

SSL 인증서에는 다음과 같은 내용이 있다.

1. 서비스의 정보 (인증서를 발급한 CA, 서비스의 도메인 등등)
2. 서버 측 공개키 (공개키의 내용, 공개키의 암호화 방법)

1번은 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지에 대한 내용을 담고 있고, 2번은 서버와 통신을 할 때 사용할 공개키와 그 공개키의 암호화 방법들의 정보를 담고 있다.

위와 같은 내용은 CA에 의해서 암호화 된다. 이 때 사용하는 암호화 기법이 공개키 방식이다. CA는 자신의 CA 비공개키를 이용해서 서버가 제출한 인증서를 암호화하는 것이다.

브라우저는 내부적으로 CA의 리스트를 미리 파악하고 있다.

이 말은 브라우저의 소스코드 안에 CA의 리스트가 들어있다는 것이다.

CA와 브라우저가 특정 서버를 인증하는 과정은 다음과 같다.

    1. 웹 브라우저가 서버에 접속할 때 서버는 제일 먼저 인증서를 제공한다.
    2. 브라우저는 이 인증서를 발급한 CA가 자신이 내장한 CA의 리스트에 있는지를 확인한다.
    3. 확인 결과 서버를 통해서 다운받은 인증서가 내장된 CA 리스트에 포함되어 있다면 해당 CA의 공개키를 이용해서 인증서를 복호화 한다.
    4. CA의 공개키를 이용해서 인증서를 복호화 할 수 있다는 것은 이 인증서가 CA의 비공개키에 의해서 암호화 된 것을 의미한다.
    5. 해당 CA의 비공개 키를 가지고 있는 CA는 해당 CA 밖에는 없기 때문에 서버가 제공한 인증서가 CA에 의해서 발급된 것이라는 것을 의미한다.
    6. CA에 의해서 발급된 인증서라는 것은 접속한 사이트가 CA에 의해서 검토되었다는 것을 의미하게 된다.
    7. CA의 검토를 통과했다는 것은 해당 서비스가 신뢰 할 수 있다는 것을 의미한다.

SSL은 암호화된 데이터를 전송하기 위해서 **공개키와 대칭키를 혼합** 해서 사용한다.

즉 클라이언트와 서버가 주고 받는 **실제 정보는 대칭키 방식으로 암호화** 하고, **대칭키 방식으로 암호화된 실제 정보** 를 복호화할 때 사용할 대칭키는 **공개키 방식** 으로 암호화해서 클라이언트와 서버가 주고 받는다.

    실제 데이터 : 대칭키
    대칭키의 키 : 공개키

컴퓨터와 컴퓨터가 네트워크를 이용해서 통신을 할 때는 내부적으로 3가지 단계가 있다.

`악수 -> 전송 -> 세션종료`

---

##### Handshaking

---

HandShaking은 이전 포스팅에 언급한 적이 있다.

SSL 방식을 이용해서 통신을 하는 브라우저와 서버 역시 핸드쉐이크를 하는데, 이 때 SSL 인증서를 주고 받는다.

공개키는 이상적인 통신 방법이다.

암호화와 복호화를 할 때 사용하는 키가 서로 다르기 때문에 메시지를 전송하는 쪽이 공개키로 데이터를 암호화하고, 수신 받는 쪽이 비공개키로 데이터를 복호화하면 되기 때문이다.

그런데 SSL에서는 이 방식을 사용하지 않는다.

왜냐하면 공개키 방식의 암호화는 매우 많은 컴퓨터 자원을 사용하기 때문이다.

반면에 암호화와 복호화에 사용되는 키가 동일한 대칭키 방식은 적은 컴퓨터 자원으로 암호화를 수행할 수 있기 때문에 효율적이지만 수신측과 송신측이 동일한 키를 공유해야 하기 때문에 보안의 문제가 발생한다.

그래서 SSL은 공개키와 대칭키의 장점을 혼합한 방법을 사용한다.

그 핸드쉐이크 단계에서 클라이언트와 서버가 통신하는 과정을 순서대로 살펴보자.

    1. 클라이언트가 서버에 접속한다. 이 단계를 `Client Hello`라고 한다. 이 단계에서 주고 받는 정보는 아래와 같다.
    클라이언트 측에서 생성한 랜덤 데이터 : 아래 3번 과정 참조
    클라이언트가 지원하는 암호화 방식들 : 클라이언트와 서버가 지원하는 암호화 방식이 서로 다를 수 있기 때문에 상호간에 어떤 암호화 방식을 사용할 것인지에 대한 협상을 해야 한다. 이 협상을 위해서 클라이언트 측에서는 자신이 사용할 수 있는 암호화 방식을 전송한다.
    세션 아이디 : 이미 SSL 핸드쉐이킹을 했다면 비용과 시간을 절약하기 위해서 기존의 세션을 재활용하게 되는데 이 때 사용할 연결에 대한 식별자를 서버 측으로 전송한다.

    2. 서버는 Client Hello에 대한 응답으로 `Server Hello`를 하게 된다. 이 단계에서 주고 받는 정보는 아래와 같다.
    서버 측에서 생성한 랜덤 데이터 : 아래 3번 과정 참조
    서버가 선택한 클라이언트의 암호화 방식 : 클라이언트가 전달한 암호화 방식 중에서 서버 쪽에서도 사용할 수 있는 암호화 방식을 선택해서 클라이언트로 전달한다. 이로써 암호화 방식에 대한 협상이 종료되고 서버와 클라이언트는 이 암호화 방식을 이용해서 정보를 교환하게 된다.
    인증서

    3. 클라이언트는 서버의 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA 리스트를 확인한다. CA 리스트에 인증서가 없다면 사용자에게 경고 메시지를 출력한다. 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA의 공개키를 이용해서 인증서를 복호화한다. 복호화에 성공했다면 인증서는 CA의 개인키로 암호화된 문서임이 암시적으로 보증된 것이다. 인증서를 전송한 서버를 믿을 수 있게 된 것이다.

    4. 클라이언트는 상기 2번을 통해서 받은 서버의 랜덤 데이터와 클라이언트가 생성한 랜덤 데이터를 조합해서 `pre master secret`라는 키를 생성한다. 이 키는 뒤에서 살펴볼 세션 단계에서 데이터를 주고 받을 때 암호화하기 위해서 사용될 것이다. 이 때 사용할 암호화 기법은 대칭키이기 때문에 pre master secret 값은 제 3자에게 `절대로 노출되어서는 안된다`.

    5. 그럼 문제는 이 pre master secret 값을 어떻게 서버에게 전달할 것인가이다. 이 때 사용하는 방법이 바로 공개키 방식이다. `서버의 공개키`로 pre master secret 값을 암호화해서 서버로 전송하면 서버는 자신의 비공개키로 안전하게 복호화 할 수 있다. 그럼 서버의 공개키는 어떻게 구할 수 있을까? `서버로부터 받은 인증서` 안에 들어있다. 이 서버의 공개키를 이용해서 pre master secret 값을 암호화한 후에 서버로 전송하면 안전하게 전송할 수 있다.

    6. 서버는 클라이언트가 전송한 pre master secret 값을 자신의 `비공개키로 복호화`한다. 이로서 서버와 클라이언트가 모두 pre master secret 값을 공유하게 되었다. 그리고 서버와 클라이언트는 모두 일련의 과정을 거쳐서 pre master secret 값을 `master secret` 값으로 만든다. master secret는 `session key를 생성`하는데 이 session key 값을 이용해서 서버와 클라이언트는 `데이터를 대칭키 방식`으로 암호화 한 후에 주고 받는다. 이렇게해서 세션키를 클라이언트와 서버가 모두 공유하게 되었다는 점을 기억하자.

    7. 클라이언트와 서버는 핸드쉐이크 단계의 종료를 서로에게 알린다.

![HTTPS](https://i.stack.imgur.com/Rcq1a.png)

---

##### 세션

---

세션은 실제로 서버와 클라이언트가 데이터를 주고 받는 단계이다.

이 단계에서 핵심은 정보를 상대방에게 전송하기 전에 session key 값을 이용해서 대칭키 방식으로 암호화 한다는 점이다.

암호화된 정보는 상대방에게 전송될 것이고, 상대방도 세션키 값을 알고 있기 때문에 암호를 복호화 할 수 있다.

그냥 공개키를 사용하면 될 것을 대칭키와 공개키를 조합해서 사용하는 이유는 무엇을까?

그것은 공개키 방식이 많은 컴퓨터 파워를 사용하기 때문이다.

만약 공개키를 그대로 사용하면 많은 접속이 몰리는 서버는 매우 큰 비용을 지불해야 할 것이다.

반대로 대칭키는 암호를 푸는 열쇠인 대칭키를 상대에게 전송해야 하는데, 암호화가 되지 않은 인터넷을 통해서 키를 전송하는 것은 위험하기 때문이다.

그래서 속도는 느리지만 데이터를 안전하게 주고 받을 수 있는 공개키 방식으로 대칭키를 암호화하고,

실제 데이터를 주고 받을 때는 대칭키를 이용해서 데이터를 주고 받는 것이다.

---

##### 세션 종료

---

데이터의 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알려준다. 이 때 통신에서 사용한 대칭키인 세션키를 폐기한다.

이렇게 HTTPS 에 대해 알아보았고, 다른 면접 질문으로 넘어가자

[출처 : https://opentutorials.org/course/228/4894](https://opentutorials.org/course/228/4894)

---

### 암호화 토크닝이란 무엇이냐?

---

**Tokenization** 이라고도 부르는 암호화 토큰은, `보호할 데이터가 있을 때, 이 원본을 그대로 보내는 게 아니라 Token 이라는 데이터로 바꾸어 보내는 것`이다.

이것은 `개인정보의 유출 위험이 있는 전송 과정과 저장 단계에서 개인정보 데이터를 치환한 토큰 데이터만을 전송하고 저장함으로서 개인정보를 보호하는 접근법`이다.


[출처 : https://www.pentasecurity.co.kr/column/%ED%86%A0%ED%81%B0%ED%99%94-%EA%B8%B0%EC%88%A0%EC%9D%B4%EB%9E%80/](https://www.pentasecurity.co.kr/column/%ED%86%A0%ED%81%B0%ED%99%94-%EA%B8%B0%EC%88%A0%EC%9D%B4%EB%9E%80/)

**JWT(Json Web Token)** 을 이용해 웹 정보 전송 암호화를 진행했던 적이 있다.

기존에 Session으로 정보를 저장하던 것을 각 클라이언트에 토크닝하여 저장하고, 이를 이용해 복호화를 진행하면 손쉽게 해당 유저의 정보를 가져올 수 있다.

**OAuth** 개념도 알아두면 좋다.

가장 간단하게 설명하면, `누군가가 나에게 일부 권한를 양도하는 것`이다.

흔히, 소셜 로그인을 사용할 때 많이 사용한다.

우리가 직접 로그인기능을 구현하거나, 회원가입기능을 구현할 수 있지만 간단히 소셜 로그인을 하면 해당 사용자의 제한된 정보를 얻어 로그인 시킬 수 있다.

즉, 특정 기능과 리소스에 접근할 수 있는 `Access Token`이라는 것을 얻게 되고, 이를 이용해 로그인을 하며 제한된 정보를 얻을 수 있는 것이다.

`3rd party를 위한 범용적인 인증 표준`이며, 사용자 임시 인증을 하는 것이다.

---

### 세션과 쿠키의 차이가 무엇인가?

---

세션과 쿠키는 상당히 자주 나오는 면접 문제이다. 알고는 있어도, 정확하게 아는게 중요하니 정리를 해보겠다.

이 둘을 설명하기 전에 HTTP의 성질을 먼저 말해보자.

HTTP는 2가지 성질을 갖고 있는데,

    1. Connectionless : 클라이언트가 Request를 보내면, 서버는 클라이언트에게 Response를 보내고 서로 접속을 끊는 특성이다.

    2. Stateless : 접속이 끊기면 서버와 클라이언트의 상태 정보는 유지되지 않는다.

즉, 저장을 하지 않음으로써, 리소스를 낭비하지는 않지만, 매번 해당 정보를 가져와야한다.

따라서 이때 쿠키와 세션을 사용한다.

---

#### 쿠키

---

**쿠키(Cookie)** 는 클라이언트에 저장되며, 키와 값이 있는 작은 파일이다.

이름, 값, 만료 날짜(저장 기간), 경로 정보가 있다.

일정시간동안 데이터를 저장할 수 있어 해당 상태를 유지한다.

---

#### 세션

---

**세션(Session)** 은 클라이언트와 웹서버간 통신을 유지시키는 것이다.

즉, 사용자가  브라우저를 열어 서버에 접속한 뒤 접속을 종료할 때 시점까지를 말한다

앞서, Connectionless와 Stateless에 대한 사항을 Session이 해결해준다.

클라이언트가 웹 서버에 Request 하면, 해당 서버 엔진이 클라이언트에 유일한 ID를 생성해주는데, 이게 세션이다.

세션 ID는 임시로 저장하여 페이지 이동시 사용하거나, 클라이언트의 재접속시 클라이언트를 구분하는 기준이 된다.


---

#### 가장 큰 차이점

---

위 둘의 가장 큰 차이점은 결국 저장 위치다.

클라이언트에 저장되는 쿠키, 서버에 저장되는 세션으로 아무래도 서버에 부하가 많이가고 느리기도 하다.

그럼 다음에는 또 다른 통신, 자료구조, OS등에 대해 하나씩 알아보자.
